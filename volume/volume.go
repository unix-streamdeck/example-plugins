package main

import (
    "context"
    "errors"
    "github.com/the-jonsey/pulseaudio"
    "github.com/unix-streamdeck/api"
    "github.com/unix-streamdeck/streamdeckd/streamdeckd"
    "golang.org/x/sync/semaphore"
    "image"
    "log"
    "math"
    "os"
    "strconv"
)

type VolumeLcdHandler struct {
    Running    bool
    Quit       chan bool
    Lock       *semaphore.Weighted
    MuteBuff   image.Image
    UnmuteBuff image.Image
    DevType    string
    InputName  string
    Props      map[string]string
    Mute       bool
    Volume     int
    FirstLoop  bool
    client     *pulseaudio.Client
}

func (v *VolumeLcdHandler) Start(knob api.KnobConfigV3, info api.StreamDeckInfoV1, callback func(image image.Image)) {
    if v.Quit == nil {
        v.Quit = make(chan bool)
    }
    if v.Lock == nil {
        v.Lock = semaphore.NewWeighted(1)
    }
    if v.MuteBuff == nil {
        v.MuteBuff = v.GetImage("mute_icon", knob, info)
    }
    if v.UnmuteBuff == nil {
        v.UnmuteBuff = v.GetImage("unmute_icon", knob, info)
    }
    devType, ok := knob.KnobOrTouchHandlerFields["device_type"]
    if !ok {
        log.Println("Device type missing")
        return
    }
    if devType == "sink_input" || devType == "source_output" {
        var inputName string
        props := make(map[string]string)
        inputName, ok := knob.KnobOrTouchHandlerFields["input_name"].(string)
        if !ok {
            propss, ok := knob.KnobOrTouchHandlerFields["props"]
            if !ok {
                log.Println("No Input Name or Props")
                return
            }
            for key, value := range propss.(map[string]interface{}) {
                if value == nil {
                    continue
                }
                props[key] = value.(string)
            }
        }
        v.InputName = inputName
        v.Props = props
    }
    v.DevType = devType.(string)
    v.Running = true
    v.Run(knob, info, callback)
}
func (v *VolumeLcdHandler) IsRunning() bool {
    return v.Running
}

func (v *VolumeLcdHandler) SetRunning(running bool) {
    v.Running = running
}

func (v *VolumeLcdHandler) Stop() {
    v.Running = false
    v.Quit <- true
}

func (v *VolumeLcdHandler) GetImage(index string, knob api.KnobConfigV3, info api.StreamDeckInfoV1) image.Image {
    path, ok := knob.LcdHandlerFields[index]
    if !ok {
        log.Println("image missing: " + index)
        return image.NewNRGBA(image.Rect(0, 0, info.LcdWidth, info.LcdHeight))
    }
    f, err := os.Open(path.(string))
    defer f.Close()
    if err != nil {
        log.Println(err)
        return image.NewNRGBA(image.Rect(0, 0, info.LcdWidth, info.LcdHeight))
    }
    img, _, err := image.Decode(f)
    if err != nil {
        log.Println(err)
        return image.NewNRGBA(image.Rect(0, 0, info.LcdWidth, info.LcdHeight))
    }
    return api.ResizeImageWH(img, info.LcdWidth, info.LcdHeight)
}

func (v *VolumeLcdHandler) Run(knob api.KnobConfigV3, info api.StreamDeckInfoV1, callback func(image image.Image)) {
    ctx := context.Background()
    err := v.Lock.Acquire(ctx, 1)
    if err != nil {
        return
    }
    var subscriptionMask pulseaudio.DevType
    if v.DevType == "sink" {
        subscriptionMask = pulseaudio.SUBSCRIPTION_MASK_SINK
    } else if v.DevType == "source" {
        subscriptionMask = pulseaudio.SUBSCRIPTION_MASK_SOURCE
    } else if v.DevType == "sink_input" {
        subscriptionMask = pulseaudio.SUBSCRIPTION_MASK_SINK_INPUT
    } else if v.DevType == "source_output" {
        subscriptionMask = pulseaudio.SUBSCRIPTION_MASK_SINK_INPUT
    }
    defer v.Lock.Release(1)
    updates, err := v.client.UpdatesByType(subscriptionMask)
    if err != nil {
        return
    }
    err = update(v, info, callback)
    if err != nil {
        log.Println(err)
    }
    for range updates {
        select {
        case <-v.Quit:
            return
        default:
            err := update(v, info, callback)
            if err != nil {
                log.Println(err)
            }
        }
    }
}

func update(v *VolumeLcdHandler, info api.StreamDeckInfoV1, callback func(image image.Image)) error {
    var device pulseaudio.Device
    var err error
    if v.DevType == "sink" {
        device, err = v.client.GetDefaultSink()
    } else if v.DevType == "source" {
        device, err = v.client.GetDefaultSource()
    } else if v.DevType == "sink_input" {
        var devices []pulseaudio.SinkInput
        if v.InputName == "" {
            devices, err = v.client.GetSinkInputsByProps(v.Props)
        } else {
            devices, err = v.client.GetSinkInputsByName(v.InputName)
        }
        if len(devices) < 1 {
            err = errors.New("No Device Found")
        } else {
            device = devices[0]
        }
    } else if v.DevType == "source_output" {
        var devices []pulseaudio.SourceOutput
        if v.InputName == "" {
            devices, err = v.client.GetSourceOutputsByProps(v.Props)
        } else {
            devices, err = v.client.GetSourceOutputsByName(v.InputName)
        }
        if len(devices) < 1 {
            err = errors.New("No Device Found")
        } else {
            device = devices[0]
        }
    }
    if err != nil {
        img := image.NewNRGBA(image.Rect(0, 0, info.LcdWidth, info.LcdHeight))
        var text string
        if v.DevType == "sink" || v.DevType == "source" {
            text = "Could not find default " + v.DevType
        } else if v.DevType == "sink_input" {
            text = "Could not find sink input"
        } else if v.DevType == "source_output" {
            text = "Could not find source output"
        }
        imgParsed, err2 := api.DrawText(img, text, 24, "MIDDLE")
        if err2 != nil {
            log.Println(err2)
        } else {
            callback(imgParsed)
        }
        return err
    } else {
        var text string
        mute := device.IsMute()
        if mute == true && mute == v.Mute && !v.FirstLoop {
            return nil
        }
        v.Mute = mute
        var img image.Image
        if mute {
            text = "Muted"
            img = v.MuteBuff
        } else {
            vol := int(math.Round(float64(device.GetVolume()) * 100))
            if vol == v.Volume && !v.FirstLoop {
                return nil
            }
            v.Volume = vol
            text = strconv.Itoa(vol) + "%"
            img = v.UnmuteBuff
        }
        if img == nil {
            image.NewNRGBA(image.Rect(0, 0, info.LcdWidth, info.LcdHeight))
        }
        imgParsed, err := api.DrawText(img, text, 24, "BOTTOM")
        if err != nil {
            log.Println(err)
        } else {
            callback(imgParsed)
        }
        return nil
    }
}

type VolumeKnobOrTouchHandler struct {
    client *pulseaudio.Client
}

func (v *VolumeKnobOrTouchHandler) Input(knob api.KnobConfigV3, info api.StreamDeckInfoV1, event api.InputEvent) {
    dev, ok := knob.KnobOrTouchHandlerFields["device_type"]
    if !ok {
        log.Println("Device type missing")
        return
    }
    var err error
    if dev == "sink_input" || dev == "source_output" {
        var inputName string
        props := make(map[string]string)
        inputName, ok := knob.KnobOrTouchHandlerFields["input_name"].(string)
        if !ok {
            propss, ok := knob.KnobOrTouchHandlerFields["props"]
            if !ok {
                log.Println("No Input Name or Props")
                return
            }
            for key, value := range propss.(map[string]interface{}) {
                if value == nil {
                    continue
                }
                props[key] = value.(string)
            }
        }
        if dev == "sink_input" {
            var devices []pulseaudio.SinkInput
            if inputName == "" {
                devices, err = v.client.GetSinkInputsByProps(props)
            } else {
                devices, err = v.client.GetSinkInputsByName(inputName)
            }
            if err != nil {
                log.Println(err)
                return
            }
            for _, device := range devices {
                updateDevice(device, event)
            }
        } else {
            var devices []pulseaudio.SourceOutput
            if inputName == "" {
                devices, err = v.client.GetSourceOutputsByProps(props)
            } else {
                devices, err = v.client.GetSourceOutputsByName(inputName)
            }
            if err != nil {
                log.Println(err)
                return
            }
            for _, device := range devices {
                updateDevice(device, event)
            }
        }

    } else {
        var device pulseaudio.Device
        if dev == "sink" {
            device, err = v.client.GetDefaultSink()
        } else if dev == "source" {
            device, err = v.client.GetDefaultSource()
        }
        if device == nil {
            err = errors.New("No device found")
        }
        if err != nil {
            log.Println(err)
            return
        }
        updateDevice(device, event)
    }
}

func updateDevice(device pulseaudio.Device, event api.InputEvent) {
    muted := device.IsMute()
    if event.EventType == api.KNOB_CCW {
        if !muted && device.GetVolume() > 0 {
            device.SetVolume(device.GetVolume() - (float32(event.RotateNotches) * 0.01))
        }
    } else if event.EventType == api.KNOB_CW {
        if !muted && device.GetVolume() < 1 {
            device.SetVolume(device.GetVolume() + (float32(event.RotateNotches) * 0.01))
        }
    } else if event.EventType == api.KNOB_PRESS || event.EventType == api.SCREEN_SHORT_TAP {
        device.ToggleMute()
    }
}

type VolumeKeyHandler struct {
    client *pulseaudio.Client
}

func (v *VolumeKeyHandler) Key(key api.KeyConfigV3, info api.StreamDeckInfoV1) {
    dev, ok := key.KeyHandlerFields["device_type"]
    if !ok {
        log.Println("Device type missing")
        return
    }
    var err error
    if dev == "sink_input" || dev == "source_output" {
        var inputName string
        props := make(map[string]string)
        inputName, ok := key.KeyHandlerFields["input_name"].(string)
        if !ok {
            propss, ok := key.KeyHandlerFields["props"]
            if !ok {
                log.Println("No Input Name or Props")
                return
            }
            for key, value := range propss.(map[string]interface{}) {
                if value == nil {
                    continue
                }
                props[key] = value.(string)
            }
        }
        if dev == "sink_input" {
            var devices []pulseaudio.SinkInput
            if inputName == "" {
                devices, err = v.client.GetSinkInputsByProps(props)
            } else {
                devices, err = v.client.GetSinkInputsByName(inputName)
            }
            if err != nil {
                log.Println(err)
                return
            }
            for _, device := range devices {
                updateDevice(device, api.InputEvent{EventType: api.KNOB_PRESS})
            }
        } else {
            var devices []pulseaudio.SourceOutput
            if inputName == "" {
                devices, err = v.client.GetSourceOutputsByProps(props)
            } else {
                devices, err = v.client.GetSourceOutputsByName(inputName)
            }
            if err != nil {
                log.Println(err)
                return
            }
            for _, device := range devices {
                updateDevice(device, api.InputEvent{EventType: api.KNOB_PRESS})
            }
        }

    } else {
        var device pulseaudio.Device
        if dev == "sink" {
            device, err = v.client.GetDefaultSink()
        } else if dev == "source" {
            device, err = v.client.GetDefaultSource()
        }
        if device == nil {
            err = errors.New("No device found")
        }
        if err != nil {
            log.Println(err)
            return
        }
        updateDevice(device, api.InputEvent{EventType: api.KNOB_PRESS})
    }

}

func GetModule() streamdeckd.Module {
    return streamdeckd.Module{
        NewLcd: func() api.LcdHandler {
            client, err := pulseaudio.NewClient()
            if err != nil {
                panic(err)
            }
            return &VolumeLcdHandler{Running: true, Lock: semaphore.NewWeighted(1), FirstLoop: true, client: client}
        },
        LcdFields: []api.Field{{Title: "Unmuted Icon", Name: "unmute_icon", Type: "File", FileTypes: []string{".png", ".jpg", ".jpeg"}}, {Title: "Muted Icon", Name: "mute_icon", Type: "File"}, {Title: "Device Type", Name: "device_type", Type: "Text"}, {Title: "Input Name", Name: "input_name", Type: "Text"}, {Title: "Props", Name: "props", Type: "Text"}},
        NewKnobOrTouch: func() api.KnobOrTouchHandler {
            client, err := pulseaudio.NewClient()
            if err != nil {
                panic(err)
            }
            return &VolumeKnobOrTouchHandler{client: client}
        },
        KnobOrTouchFields: []api.Field{{Title: "Device Type", Name: "device_type", Type: "Text"}, {Title: "Input Name", Name: "input_name", Type: "Text"}, {Title: "Props", Name: "props", Type: "Text"}},
        NewKey: func() api.KeyHandler {
            client, err := pulseaudio.NewClient()
            if err != nil {
                panic(err)
            }
            return &VolumeKeyHandler{client: client}
        },
        KeyFields: []api.Field{{Title: "Device Type", Name: "device_type", Type: "Text"}, {Title: "Input Name", Name: "input_name", Type: "Text"}, {Title: "Props", Name: "props", Type: "Text"}},

        Name: "Volume",
    }
}
